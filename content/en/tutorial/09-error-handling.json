{"meta":{"title":"Error Handling","prev":"/tutorial/08-keys","next":"/tutorial/10-links","solvable":true,"tutorial":{"setup":"useResult(function(result) {\n  var options = require('preact').options;\n\n  var oe = options.__e;\n  options.__e = function(error, s) {\n    if (/objects are not valid/gi.test(error)) {\n      throw Error('It looks like you might be trying to render an Error object directly: try storing `error.message` instead of `error` itself.');\n    }\n    oe.apply(this, arguments);\n    setTimeout(function() {\n      if (result.output.textContent.match(/error/i)) {\n        solutionCtx.setSolved(true);\n      }\n    }, 10);\n  };\n\n  return function () {\n    options.__e = oe;\n  };\n}, []);","initial":"import { render, Component } from 'preact';\nimport { useState } from 'preact/hooks';\n\nfunction Clicker() {\n  const [clicked, setClicked] = useState(false);\n\n  if (clicked) {\n    throw new Error('I am erroring');\n  }\n\n  return <button onClick={() => setClicked(true)}>Click Me</button>;\n}\n\nclass App extends Component {\n  state = { error: null };\n\n  render() {\n    return <Clicker />;\n  }\n}\n\nrender(<App />, document.getElementById(\"app\"));","final":"import { render, Component } from 'preact';\nimport { useState } from 'preact/hooks';\n\nfunction Clicker() {\n  const [clicked, setClicked] = useState(false);\n\n  if (clicked) {\n    throw new Error('I am erroring');\n  }\n\n  return <button onClick={() => setClicked(true)}>Click Me</button>;\n}\n\nclass App extends Component {\n  state = { error: null };\n\n  componentDidCatch(error) {\n    this.setState({ error: error.message });\n  }\n\n  render() {\n    const { error } = this.state;\n    if (error) {\n      return <p>Oh no! There was an error: {error}</p>\n    }\n    return <Clicker />;\n  }\n}\n\nrender(<App />, document.getElementById(\"app\"));"}},"html":"<h1>Error Handling</h1><p>JavaScript is a flexible interpreted language, which means it&#39;s possible (and even easy)\nto encounter errors at runtime. Whether the result of an unexpected scenario or a mistake\nin code we&#39;ve written, it&#39;s important to be able to monitor errors and implement some form\nof recovery or graceful error handling.</p>\n<p>In Preact, the way we do this is to capture errors and save them as state. This lets\na component intercept an unexpected or broken render and switch to rendering something\ndifferent as a fallback.</p>\n\n\t\t\t\t<h3 id=\"turning-errors-into-state\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#turning-errors-into-state\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Turning errors into state (#turning-errors-into-state)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Turning errors into state</span>\n\t\t\t\t</h3><p>Two APIs are available for capturing errors and turning them into state:\n<code>componentDidCatch</code> and <code>getDerivedStateFromError</code>. They&#39;re functionally similar,\nand both are methods you can implement on a class component:</p>\n<p><strong>componentDidCatch</strong> gets passed an <code>Error</code> argument, and can decide what to do\nin response to that Error on a case-by-case basis. It can call <code>this.setState()</code>\nto render a fallback or alternative tree, which will &quot;catch&quot; the error and mark\nit as handled. Or, the method could simply log the error somewhere and allow it\nto continue unhandled (to crash).</p>\n<p><strong>getDerivedStateFromError</strong> is a static method that gets passed an <code>Error</code>,\nand returns a state update object, which is applied to the component via\n<code>setState()</code>. Since this method always produces a state change that results\nin its component being re-rendered, it always marks errors as handled.</p>\n<p>The following example shows how to use either method to capture errors\nand show a graceful error message instead of crashing:</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'preact'</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ErrorBoundary</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">error</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromError</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">error</span><span class=\"token operator\">:</span> error<span class=\"token punctuation\">.</span>message <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidCatch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">error</span><span class=\"token operator\">:</span> error<span class=\"token punctuation\">.</span>message <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Oh no! We ran into an error: </span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>error<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n\t\t\t\t\t\n\t\t\t\t</div>\n\t\t\t<p>The component above is a relatively common example of how error handling is\nimplemented in Preact applications, often referred to as an <em>Error Boundary</em>.</p>\n\n\t\t\t\t<h3 id=\"nesting-and-error-bubbling\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#nesting-and-error-bubbling\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Nesting and error bubbling (#nesting-and-error-bubbling)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Nesting and error bubbling</span>\n\t\t\t\t</h3><p>Errors encountered when Preact is rendering your Virtual DOM tree &quot;bubble up&quot;,\nmuch like DOM events. Starting from the component that encountered the error,\neach parent component in the tree is given an opportunity to handle the error.</p>\n<p>As a result, Error Boundaries can be nested if implemented using <code>componentDidCatch</code>.\nWhen a component&#39;s <code>componentDidCatch()</code> method <em>doesn&#39;t</em> call <code>setState()</code>, the\nerror will continue to bubble up the Virtual DOM tree until it reaches a component\nwith a <code>componentDidCatch</code> method that <em>does</em> call <code>setState()</code>.</p>\n\n\t\t\t\t<h2 id=\"try-it\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#try-it\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Try it! (#try-it)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Try it!</span>\n\t\t\t\t</h2><p>To test our error handling knowledge, let&#39;s add error handling to a simple App\ncomponent. One of the components deep within App can throw an error in some\nscenario, and we want to catch this so we can show a friendly message telling\nthe user that we&#39;ve run into an unexpected error.</p>\n<solution>\n  <h4>ðŸŽ‰ Congratulations!</h4>\n  <p>You learned how to handle errors in Preact code!</p>\n</solution>\n\n\n\n\n\n\n\n\n"}