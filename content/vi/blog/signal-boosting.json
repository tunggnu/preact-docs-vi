{"meta":{"title":"Signal Boosting","date":"2022-09-24","authors":["Joachim Viide"]},"html":"<h1>Signal Boosting</h1><p>The new release of Preact Signals brings significant performance updates to the foundations of the reactive system. Read on to learn what kinds of tricks we employed to make this happen.</p>\n<p>We recently <a href=\"https://twitter.com/jviide/status/1572570215350964224\" target=\"_blank\" rel=\"noopener noreferrer\">announced</a> new versions of the Preact Signals packages:</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/@preact/signals-core\" target=\"_blank\" rel=\"noopener noreferrer\">@preact/signals-core</a> 1.2.0 for the shared core functionality</li>\n<li><a href=\"https://www.npmjs.com/package/@preact/signals\" target=\"_blank\" rel=\"noopener noreferrer\">@preact/signals</a> 1.1.0 for the Preact bindings</li>\n<li><a href=\"https://www.npmjs.com/package/@preact/signals-react\" target=\"_blank\" rel=\"noopener noreferrer\">@preact/signals-react</a> 1.1.0 for the React bindings</li>\n</ul>\n<p>This post will outline the steps that we took to optimize <strong>@preact/signals-core</strong>. It&#39;s the package that acts as a base for the framework specific bindings, but can also be used independently.</p>\n<p>Signals are the Preact team&#39;s take on reactive programming. If you want a gentle introduction on what Signals are all about and how they tie in with Preact, <a href=\"/blog/introducing-signals\">the Signals announcement blog post</a> has got you covered. For a deeper dive check out the <a href=\"/guide/v10/signals\">official documentation</a>.</p>\n<p>It should be noted that none of these concepts are invented by us. Reactive programming has quite a history, and has already been popularized widely in the JavaScript world by <a href=\"https://vuejs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Vue.js</a>, <a href=\"https://svelte.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">Svelte</a>, <a href=\"https://www.solidjs.com/\" target=\"_blank\" rel=\"noopener noreferrer\">SolidJS</a>, <a href=\"https://rxjs.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">RxJS</a> and too many others to name. Kudos to all of them!</p>\n\n\t\t\t\t<h2 id=\"a-whirlwind-tour-of-the-signals-core\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#a-whirlwind-tour-of-the-signals-core\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: A Whirlwind Tour of the Signals Core (#a-whirlwind-tour-of-the-signals-core)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>A Whirlwind Tour of the Signals Core</span>\n\t\t\t\t</h2><p>Let&#39;s start with an overview of the fundamental features in the <strong>@preact/signals-core</strong> package.</p>\n<p>The code snippets below use functions imported from the package. The import statements are shown only when a new function is brought into the mix.</p>\n\n\t\t\t\t<h3 id=\"signals\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#signals\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Signals (#signals)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Signals</span>\n\t\t\t\t</h3><p>Plain <em>signals</em> are the fundamental root values which our reactive system is based on. Other libraries might call them, for example, &quot;observables&quot; (<a href=\"https://mobx.js.org/observable-state.html\" target=\"_blank\" rel=\"noopener noreferrer\">MobX</a>, <a href=\"https://rxjs.dev/guide/observable\" target=\"_blank\" rel=\"noopener noreferrer\">RxJS</a>) or &quot;refs&quot; (<a href=\"https://vuejs.org/guide/extras/reactivity-in-depth.html#how-reactivity-works-in-vue\" target=\"_blank\" rel=\"noopener noreferrer\">Vue</a>). The Preact team adopted the term &quot;signal&quot; used by <a href=\"https://www.solidjs.com/tutorial/introduction_signals\" target=\"_blank\" rel=\"noopener noreferrer\">SolidJS</a>.</p>\n<p>Signals represent arbitrary JavaScript values wrapped into a reactive shell. You provide a signal with an initial value, and can later read and update it as you go.</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> signal <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@preact/signals-core\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> s <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: 0</span>\n\ns<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: 1</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsIH0gZnJvbSAiQHByZWFjdC9zaWduYWxzLWNvcmUiOwoKY29uc3QgcyA9IHNpZ25hbCgwKTsKY29uc29sZS5sb2cocy52YWx1ZSk7IC8vIENvbnNvbGU6IDAKCnMudmFsdWUgPSAxOwpjb25zb2xlLmxvZyhzLnZhbHVlKTsgLy8gQ29uc29sZTogMQ%3D%3D\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>By themselves signals are not terribly interesting until combined with the two other primitives, <em>computed signals</em> and <em>effects</em>.</p>\n\n\t\t\t\t<h3 id=\"computed-signals\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#computed-signals\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Computed Signals (#computed-signals)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Computed Signals</span>\n\t\t\t\t</h3><p><em>Computed signals</em> derive new values from other signals using <em>compute functions</em>.</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> signal<span class=\"token punctuation\">,</span> computed <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@preact/signals-core\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> s1 <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> s2 <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"World\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> s1<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCB9IGZyb20gIkBwcmVhY3Qvc2lnbmFscy1jb3JlIjsKCmNvbnN0IHMxID0gc2lnbmFsKCJIZWxsbyIpOwpjb25zdCBzMiA9IHNpZ25hbCgiV29ybGQiKTsKCmNvbnN0IGMgPSBjb21wdXRlZCgoKSA9PiB7CiAgcmV0dXJuIHMxLnZhbHVlICsgIiAiICsgczIudmFsdWU7Cn0pOw%3D%3D\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>The compute function given to <code>computed(...)</code> won&#39;t run immediately. That&#39;s because computed signals are evaluated <em>lazily</em>, i.e. when their values are read.</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: Hello World</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCB9IGZyb20gIkBwcmVhY3Qvc2lnbmFscy1jb3JlIjsKCmNvbnN0IHMxID0gc2lnbmFsKCJIZWxsbyIpOwpjb25zdCBzMiA9IHNpZ25hbCgiV29ybGQiKTsKCmNvbnN0IGMgPSBjb21wdXRlZCgoKSA9PiB7CiAgcmV0dXJuIHMxLnZhbHVlICsgIiAiICsgczIudmFsdWU7Cn0pOwoKY29uc29sZS5sb2coYy52YWx1ZSk7IC8vIENvbnNvbGU6IEhlbGxvIFdvcmxk\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>Computed values are also <em>cached</em>. Their compute functions can potentially be very expensive, so we want to rerun them only when it matters. A running compute function tracks which signal values are actually read during its run. If none of the values have changed, then we can skip recomputation. In the above example, we can just reuse the previously calculated <code>c.value</code> indefinitely as long as both <code>a.value</code> and <code>b.value</code> stay the same. Facilitating this <em>dependency tracking</em> is the reason why we need to wrap the primitive values into signals in the first place.</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token comment\">// s1 and s2 haven't changed, no recomputation here</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: Hello World</span>\n\ns2<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"darkness my old friend\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// s2 has changed, so the computation function runs again</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: Hello darkness my old friend</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCB9IGZyb20gIkBwcmVhY3Qvc2lnbmFscy1jb3JlIjsKCmNvbnN0IHMxID0gc2lnbmFsKCJIZWxsbyIpOwpjb25zdCBzMiA9IHNpZ25hbCgiV29ybGQiKTsKCmNvbnN0IGMgPSBjb21wdXRlZCgoKSA9PiB7CiAgcmV0dXJuIHMxLnZhbHVlICsgIiAiICsgczIudmFsdWU7Cn0pOwoKY29uc29sZS5sb2coYy52YWx1ZSk7IC8vIENvbnNvbGU6IEhlbGxvIFdvcmxkCgovLyBzMSBhbmQgczIgaGF2ZW4ndCBjaGFuZ2VkLCBubyByZWNvbXB1dGF0aW9uIGhlcmUKY29uc29sZS5sb2coYy52YWx1ZSk7IC8vIENvbnNvbGU6IEhlbGxvIFdvcmxkCgpzMi52YWx1ZSA9ICJkYXJrbmVzcyBteSBvbGQgZnJpZW5kIjsKCi8vIHMyIGhhcyBjaGFuZ2VkLCBzbyB0aGUgY29tcHV0YXRpb24gZnVuY3Rpb24gcnVucyBhZ2Fpbgpjb25zb2xlLmxvZyhjLnZhbHVlKTsgLy8gQ29uc29sZTogSGVsbG8gZGFya25lc3MgbXkgb2xkIGZyaWVuZA%3D%3D\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>As it happens, computed signals are themselves signals. A computed signal can depend on other computed signals.</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">const</span> count <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> double <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> count<span class=\"token punctuation\">.</span>value <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> quadruple <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> double<span class=\"token punctuation\">.</span>value <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>quadruple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: 4</span>\ncount<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>quadruple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: 80</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCB9IGZyb20gIkBwcmVhY3Qvc2lnbmFscy1jb3JlIjsKCmNvbnN0IGNvdW50ID0gc2lnbmFsKDEpOwpjb25zdCBkb3VibGUgPSBjb21wdXRlZCgoKSA9PiBjb3VudC52YWx1ZSAqIDIpOwpjb25zdCBxdWFkcnVwbGUgPSBjb21wdXRlZCgoKSA9PiBkb3VibGUudmFsdWUgKiAyKTsKCmNvbnNvbGUubG9nKHF1YWRydXBsZS52YWx1ZSk7IC8vIENvbnNvbGU6IDQKY291bnQudmFsdWUgPSAyMDsKY29uc29sZS5sb2cocXVhZHJ1cGxlLnZhbHVlKTsgLy8gQ29uc29sZTogODA%3D\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>The set of dependencies doesn&#39;t have to stay static. The computed signal will only react to changes in the latest set of dependencies.</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">const</span> choice <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> funk <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Uptown\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> purple <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Haze\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>choice<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>funk<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Funk\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Purple\"</span><span class=\"token punctuation\">,</span> purple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nc<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>               <span class=\"token comment\">// Console: Uptown Funk</span>\n\npurple<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"Rain\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// purple is not a dependency, so</span>\nc<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>               <span class=\"token comment\">// effect doesn't run</span>\n\nchoice<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\nc<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>               <span class=\"token comment\">// Console: Purple Rain</span>\n\nfunk<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"Da\"</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// funk not a dependency anymore, so</span>\nc<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>               <span class=\"token comment\">// effect doesn't run</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCB9IGZyb20gIkBwcmVhY3Qvc2lnbmFscy1jb3JlIjsKCmNvbnN0IGNob2ljZSA9IHNpZ25hbCh0cnVlKTsKY29uc3QgZnVuayA9IHNpZ25hbCgiVXB0b3duIik7CmNvbnN0IHB1cnBsZSA9IHNpZ25hbCgiSGF6ZSIpOwoKY29uc3QgYyA9IGNvbXB1dGVkKCgpID0%2BIHsKICBpZiAoY2hvaWNlLnZhbHVlKSB7CiAgICBjb25zb2xlLmxvZyhmdW5rLnZhbHVlLCAiRnVuayIpOwogIH0gZWxzZSB7CiAgICBjb25zb2xlLmxvZygiUHVycGxlIiwgcHVycGxlLnZhbHVlKTsKICB9Cn0pOwpjLnZhbHVlOyAgICAgICAgICAgICAgIC8vIENvbnNvbGU6IFVwdG93biBGdW5rCgpwdXJwbGUudmFsdWUgPSAiUmFpbiI7IC8vIHB1cnBsZSBpcyBub3QgYSBkZXBlbmRlbmN5LCBzbwpjLnZhbHVlOyAgICAgICAgICAgICAgIC8vIGVmZmVjdCBkb2Vzbid0IHJ1bgoKY2hvaWNlLnZhbHVlID0gZmFsc2U7CmMudmFsdWU7ICAgICAgICAgICAgICAgLy8gQ29uc29sZTogUHVycGxlIFJhaW4KCmZ1bmsudmFsdWUgPSAiRGEiOyAgICAgLy8gZnVuayBub3QgYSBkZXBlbmRlbmN5IGFueW1vcmUsIHNvCmMudmFsdWU7ICAgICAgICAgICAgICAgLy8gZWZmZWN0IGRvZXNuJ3QgcnVu\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>These three things - dependency tracking, laziness and caching - are common features in reactivity libraries. Vue&#39;s <em>computed properties</em> are <a href=\"https://dev.to/linusborg/vue-when-a-computed-property-can-be-the-wrong-tool-195j\" target=\"_blank\" rel=\"noopener noreferrer\">one prominent example</a>.</p>\n\n\t\t\t\t<h3 id=\"effects\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#effects\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Effects (#effects)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Effects</span>\n\t\t\t\t</h3><p>Computed signals lend themselves well to <a href=\"https://en.wikipedia.org/wiki/Pure_function\" target=\"_blank\" rel=\"noopener noreferrer\">pure functions</a> without side-effects. They&#39;re also lazy. So what to do if we want to react to changes in signal values without constantly polling them? Effects to the rescue!</p>\n<p>Like computed signals, effects are also created with a function (<em>effect function</em>) and also track their dependencies. However, instead of being lazy, effects are <em>eager</em>. The effect function gets run immediately when the effect gets created, and then again and again whenever the dependency values change.</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> signal<span class=\"token punctuation\">,</span> computed<span class=\"token punctuation\">,</span> effect <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"@preact/signals-core\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> count <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> double <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> count<span class=\"token punctuation\">.</span>value <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> quadruple <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> double<span class=\"token punctuation\">.</span>value <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"quadruple is now\"</span><span class=\"token punctuation\">,</span> quadruple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>               <span class=\"token comment\">// Console: quadruple value is now 4</span>\n\ncount<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Console: quadruple value is now 80</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCwgZWZmZWN0IH0gZnJvbSAiQHByZWFjdC9zaWduYWxzLWNvcmUiOwoKY29uc3QgY291bnQgPSBzaWduYWwoMSk7CmNvbnN0IGRvdWJsZSA9IGNvbXB1dGVkKCgpID0%2BIGNvdW50LnZhbHVlICogMik7CmNvbnN0IHF1YWRydXBsZSA9IGNvbXB1dGVkKCgpID0%2BIGRvdWJsZS52YWx1ZSAqIDIpOwoKZWZmZWN0KCgpID0%2BIHsKICBjb25zb2xlLmxvZygicXVhZHJ1cGxlIGlzIG5vdyIsIHF1YWRydXBsZS52YWx1ZSk7Cn0pOyAgICAgICAgICAgICAgIC8vIENvbnNvbGU6IHF1YWRydXBsZSB2YWx1ZSBpcyBub3cgNAoKY291bnQudmFsdWUgPSAyMDsgLy8gQ29uc29sZTogcXVhZHJ1cGxlIHZhbHVlIGlzIG5vdyA4MA%3D%3D\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>These reactions are triggered by <em>notifications</em>. When a plain signal changes, it notifies its immediate dependents. They in turn notify their own immediate dependents, and so on. As is <a href=\"https://mobx.js.org/computeds.html\" target=\"_blank\" rel=\"noopener noreferrer\">common</a> in reactive systems, computed signals along the notification&#39;s path mark themselves to be outdated and ready be recomputed. If the notification trickles all the way down to an effect, then that effect schedules itself to be run as soon as all previously scheduled effects have finished.</p>\n<p>When you&#39;re done with an effect, call the <em>disposer</em> that got returned when the effect was first created:</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">const</span> count <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> double <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> count<span class=\"token punctuation\">.</span>value <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> quadruple <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> double<span class=\"token punctuation\">.</span>value <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> dispose <span class=\"token operator\">=</span> <span class=\"token function\">effect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"quadruple is now\"</span><span class=\"token punctuation\">,</span> quadruple<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">// Console: quadruple value is now 4</span>\n\n<span class=\"token function\">dispose</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ncount<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// nothing gets printed to the console</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCwgZWZmZWN0IH0gZnJvbSAiQHByZWFjdC9zaWduYWxzLWNvcmUiOwoKY29uc3QgY291bnQgPSBzaWduYWwoMSk7CmNvbnN0IGRvdWJsZSA9IGNvbXB1dGVkKCgpID0%2BIGNvdW50LnZhbHVlICogMik7CmNvbnN0IHF1YWRydXBsZSA9IGNvbXB1dGVkKCgpID0%2BIGRvdWJsZS52YWx1ZSAqIDIpOwoKY29uc3QgZGlzcG9zZSA9IGVmZmVjdCgoKSA9PiB7CiAgY29uc29sZS5sb2coInF1YWRydXBsZSBpcyBub3ciLCBxdWFkcnVwbGUudmFsdWUpOwp9KTsgICAgICAgICAgICAgICAgIC8vIENvbnNvbGU6IHF1YWRydXBsZSB2YWx1ZSBpcyBub3cgNAoKZGlzcG9zZSgpOwpjb3VudC52YWx1ZSA9IDIwOyAgLy8gbm90aGluZyBnZXRzIHByaW50ZWQgdG8gdGhlIGNvbnNvbGU%3D\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>There are other functions, like <a href=\"/guide/v10/signals/#batchfn\">`batch`</a>, but these three are the most relevant to the implementation notes that follow.</p>\n<h1>Implementation Notes</h1><p>When we set out to implement more performant versions of the above primitives, we had to find snappy ways to do all the following subtasks:</p>\n<ul>\n<li>Dependency tracking: Keep track of used signals (plain or computed). The dependencies may change dynamically.</li>\n<li>Laziness: Compute functions should only run on demand.</li>\n<li>Caching: A computed signal should recompute only when its dependencies may have changed.</li>\n<li>Eagerness: An effect should run ASAP when something in its dependency chain changes.</li>\n</ul>\n<p>A reactive system can be implemented in a bajillion different ways. The first released version of <strong>@preact/signals-core</strong> was based on Sets, so we&#39;ll keep using that approach to contrast and compare.</p>\n\n\t\t\t\t<h3 id=\"dependency-tracking\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#dependency-tracking\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Dependency Tracking (#dependency-tracking)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Dependency Tracking</span>\n\t\t\t\t</h3><p>Whenever a compute/effect function starts evaluating, it needs a way to capture signals that have been read during its run. For that the computed signal or effect sets itself as the current <em>evaluation context</em>. When a signal&#39;s <code>.value</code> property is read, it calls a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\" target=\"_blank\" rel=\"noopener noreferrer\">getter</a>. The getter adds the signal as a dependency, <em>source</em>, of the evaluation context. The context also gets added as a dependent, <em>target</em>, of the signal.</p>\n<p>In the end signals and effects always have an up-to-date view of their dependencies and dependents. Each signal can then notify its dependents whenever its value has changed. Effects and computed signals can refer to their dependency sets to unsubscribe from those notifications when, say, an effect is disposed.</p>\n<p><img decoding=\"async\" src=\"/signals/signal-boosting-01.png\" alt=\"Signals and effects always have an up-to-date view of their dependencies (sources) and dependents (targets)\" ></p>\n<p>The same signal may get read multiple times inside the same evaluation context. In such cases it would be handy to do some sort of deduplication for dependency and dependent entries. We also need a way to handle changing sets of dependencies: to either rebuild the set of dependencies on every run or incrementally add/remove dependencies/dependents.</p>\n<p>JavaScript&#39;s <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\" target=\"_blank\" rel=\"noopener noreferrer\">Set</a> objects are a good fit for all that. Like many other implementations, the original version of Preact Signals used them. Sets allow adding <em>and</em> removing items in <a href=\"https://en.wikipedia.org/wiki/Time_complexity#Constant_time\" target=\"_blank\" rel=\"noopener noreferrer\">constant O(1) time</a> (amortized), as well as iterating through the current items in <a href=\"https://en.wikipedia.org/wiki/Time_complexity#Linear_time\" target=\"_blank\" rel=\"noopener noreferrer\">linear O(n) time</a>. Duplicates are also handled automatically! It&#39;s no wonder many reactivity systems take advantage of Sets (or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\" target=\"_blank\" rel=\"noopener noreferrer\">Maps</a>). The right tool for the job and all that.</p>\n<p>However, we were wondering whether there are some alternative approaches. Sets can be relatively expensive to create, and at least computed signals may need two separate Sets: one for dependencies and one for dependents. Jason was being a <em>total Jason</em> again and <a href=\"https://esbench.com/bench/6317fc2a6c89f600a5701bc9\" target=\"_blank\" rel=\"noopener noreferrer\">benchmarked</a> how Set iteration fares against Arrays. There will be lots of iterating so it all adds up.</p>\n<p><img decoding=\"async\" src=\"/signals/signal-boosting-01b.png\" alt=\"Set iteration is just a tad slower than Array iteration\" ></p>\n<p>Sets also have the property they&#39;re iterated in insertion order. Which is cool - that&#39;s just what we need later when we deal with caching. But there&#39;s the possibility that the order doesn&#39;t always stay the same. Observe the following scenario:</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">const</span> s1 <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> s2 <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> s3 <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    s2<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n    s3<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    s3<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n    s2<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n\t\t\t\t\t<a class=\"repl-link\" href=\"/repl?code=aW1wb3J0IHsgc2lnbmFsLCBjb21wdXRlZCB9IGZyb20gIkBwcmVhY3Qvc2lnbmFscy1jb3JlIjsKCmNvbnN0IHMxID0gc2lnbmFsKDApOwpjb25zdCBzMiA9IHNpZ25hbCgwKTsKY29uc3QgczMgPSBzaWduYWwoMCk7Cgpjb25zdCBjID0gY29tcHV0ZWQoKCkgPT7CoHsKICBpZiAoczEudmFsdWUpIHsKICAgIHMyLnZhbHVlOwogICAgczMudmFsdWU7CiAgfSBlbHNlIHsKICAgIHMzLnZhbHVlOwogICAgczIudmFsdWU7CiAgfQp9KTs%3D\">Run in REPL</a>\n\t\t\t\t</div>\n\t\t\t<p>Depending on <code>s1</code> the order of dependencies is either <code>s1, s2, s3</code> or <code>s1, s3, s2</code>. Special steps have to be taken to keep Sets in order: either remove and then add back items, empty the set before a function run, or create a new set for each run. Each approach has the potential to cause memory churn. And all this just to account for the theoretical, but probably rare, case that the order of dependencies changes.</p>\n<p>There are multiple other ways to deal with this. For example numbering and then sorting the dependencies. We ended up exploring <a href=\"https://en.wikipedia.org/wiki/Linked_list\" target=\"_blank\" rel=\"noopener noreferrer\">linked lists</a>.</p>\n\n\t\t\t\t<h3 id=\"linked-lists\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#linked-lists\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Linked Lists (#linked-lists)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Linked Lists</span>\n\t\t\t\t</h3><p>Linked lists are often considered quite primitive, but for our purposes they have some very nice properties. If you have a doubly-linked list nodes then the following operations can be extremely cheap:</p>\n<ul>\n<li>Insert an item to one end of the list in O(1) time.</li>\n<li>Remove a node (for which you already have a pointer) from anywhere in the list in O(1) time.</li>\n<li>Iterate through the list in O(n) time (O(1) per node)</li>\n</ul>\n<p>Turns out that these operations are all we need for managing dependency/dependent lists.</p>\n<p>Let&#39;s start by creating a &quot;source Node&quot; for each dependency relation. The Node&#39;s <code>source</code> attribute points to the signal that&#39;s being depended on. Each Node has <code>nextSource</code> and <code>prevSource</code> properties pointing to the next and previous source Nodes in the dependency list, respectively. Effects or a computed signals get a <code>sources</code> attribute pointing to the first Node of the list. Now we can iterate through the dependencies, insert a new dependency, and remove dependencies from the list for reordering.</p>\n<p><img decoding=\"async\" src=\"/signals/signal-boosting-02.png\" alt=\"Effects and computed signals keep their dependencies in a doubly-linked list\" ></p>\n<p>Now let&#39;s do the same the other way around: For each dependent create a &quot;target Node&quot;. The Node&#39;s <code>target</code> attribute points to the dependent effect or computed signal. <code>nextTarget</code> and <code>prevTarget</code> build a doubly linked list. Plain and computed signal get a <code>targets</code> attribute pointing to the first target Node in their dependent list.</p>\n<p><img decoding=\"async\" src=\"/signals/signal-boosting-03.png\" alt=\"Signals keep their dependents in a doubly-linked list\" ></p>\n<p>But hey, dependencies and dependents come in pairs. For every source Node there <strong>must</strong> be a corresponding target Node. We can exploit this fact and smush &quot;source Nodes&quot; and &quot;target Nodes&quot; into just &quot;Nodes&quot;. Each Node becomes a sort of quad-linked monstrosity that the dependent can use as a part of its dependency list, and vice versa.</p>\n<p><img decoding=\"async\" src=\"/signals/signal-boosting-04.png\" alt=\"Each Node becomes a sort of quad-linked monstrosity that the dependent can use as a part of its dependency list, and vice versa\" ></p>\n<p>Each Node can have additional stuff attached to it for bookkeeping purposes. Before each compute/effect function we iterate through the previous dependencies and set the &quot;unused&quot; flag of each Node. We also temporarily store the Node to its <code>.source.node</code> property for later. The function can then start its run.</p>\n<p>During the run, each time a dependency is read, the bookkeeping values can be used to discover whether that dependency has already been seen during this or the previous run. If the dependency is from the previous run, we can recycle its Node. For previously unseen dependencies we create new Nodes. The Nodes are then shuffled around to keep them in reverse order of use. At the end of the run we walk through the dependency list again, purging Nodes that are still hanging around with the &quot;unused&quot; flag set. Then we reverse the list of remaining nodes to keep it all neat for later consumption.</p>\n<p>This delicate dance of death allows us to allocate only one Node per each dependency-dependent pair and then use that Node indefinitely as long as the dependency relationship exists. If the dependency tree stays stable, memory consumption also stays effectively stable after the initial build phase. All the while dependency lists stay up to date and in order of use. With a constant O(1) amount of work per Node. Nice!</p>\n\n\t\t\t\t<h3 id=\"eager-effects\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#eager-effects\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Eager Effects (#eager-effects)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Eager Effects</span>\n\t\t\t\t</h3><p>With the dependency tracking taken care of, eager effects are relatively straightforward to implement via change-notifications. Signals notify their dependents about value changes. If the dependent itself is a computed signal that has dependents, then it passes the notification forward, and so on. Effects that get a notification schedule themselves to be run.</p>\n<p>We added a couple of optimizations here. If the receiving end of a notification has already been notified before, and it hasn&#39;t yet had a chance to run, then it won&#39;t pass the notification forward. This mitigates cascading notification stampedes when the dependency tree fans out or in. Plain signals also don&#39;t notify their dependents if the signal&#39;s value doesn&#39;t actually change (e.g. <code>s.value = s.value</code>). But that&#39;s just being polite.</p>\n<p>For effects to be able to schedule themselves there needs to be some sort of a list of scheduled effects. We added an dedicated attribute <code>.nextBatchedEffect</code> to each Effect instance, letting Effect instances do double duty as nodes in a singly-linked scheduling list. This reduces memory churn, because scheduling the same effect again and again requires no additional memory allocations or deallocations.</p>\n\n\t\t\t\t<h3 id=\"interlude:-notification-subscriptions-vs-gc\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#interlude:-notification-subscriptions-vs-gc\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Interlude: Notification Subscriptions vs. GC (#interlude:-notification-subscriptions-vs-gc)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Interlude: Notification Subscriptions vs. GC</span>\n\t\t\t\t</h3><p>We haven&#39;t been completely truthful. Computed signals don&#39;t actually <em>always</em> get notifications from their dependencies. A computed signal subscribes to dependency notifications only when there&#39;s something, like an effect, listening to the signal itself. This avoids problems in situations like this:</p>\n\n\t\t\t\t<div class=\"highlight-container\">\n\t\t\t\t\t<pre class=\"highlight\"><code class=\"language-js\"><span class=\"token keyword\">const</span> s <span class=\"token operator\">=</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> c <span class=\"token operator\">=</span> <span class=\"token function\">computed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> s<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// c has gone out of scope</span></code></pre>\n\t\t\t\t\t\n\t\t\t\t</div>\n\t\t\t<p>Were <code>c</code> to always subscribe to notifications from <code>s</code>, then <code>c</code> couldn&#39;t get garbage collected until <code>s</code> too falls out of scope. That&#39;s because <code>s</code> would keep hanging on to a reference to <code>c</code>.</p>\n<p>There are multiple solutions to this problem, like using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef\" target=\"_blank\" rel=\"noopener noreferrer\">WeakRefs</a> or requiring computed signals to be manually disposed. In our case linked lists provide a very convenient way to dynamically subscribe and unsubscribe to dependency notifications on the fly, thanks to all that O(1) stuff. The end result is that you don&#39;t have to pay any special attention to dangling computed signal references. We felt this was the most ergonomic and performant approach.</p>\n<p>In those cases where a computed signal <strong>has</strong> subscribed to notifications we can use that knowledge for extra optimizations. This brings us to laziness &amp; caching.</p>\n\n\t\t\t\t<h3 id=\"lazy--cached-computed-signals\">\n\t\t\t\t\t<a class=\"fragment-link\" href=\"#lazy--cached-computed-signals\">\n\t\t\t\t\t\t<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" aria-label=\"Link to: Lazy & Cached Computed Signals (#lazy--cached-computed-signals)\">\n\t\t\t\t\t\t\t<use href=\"/icons.svg#link\" ></use>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</a>\n\t\t\t\t\t<span>Lazy & Cached Computed Signals</span>\n\t\t\t\t</h3><p>The easiest way to implement a lazy computed signal would be to just recompute each time its value is read. It wouldn&#39;t be very efficient, though. That&#39;s where caching and dependency tracking help a bunch.</p>\n<p>Each plain and computed signal has their own <em>version number</em>. They increment their version numbers every time they&#39;ve noticed their own value change. When a compute function is run, it stores in the Nodes the last seen version numbers of its dependencies. We could have chosen to store the previous dependency values in the nodes instead of version numbers. However, since computed signals are lazy, they could therefore hang on to outdated and potentially expensive values indefinitely. So we felt version numbering was a safe compromise.</p>\n<p>We ended up with the following algorithm for figuring out when a computed signal can take the day off and reuse its cached value:</p>\n<ol>\n<li>If the no signal anywhere has changed values since the last run, then bail out &amp; return the cached value.</li>\n</ol>\n<blockquote>\n<p>Each time a plain signal changes it also increments a <em>global version number</em>, shared between all plain signals. Each computed signal keeps track of the last global version number they&#39;ve seen. If the global version hasn&#39;t changed since last computation, then recomputation can be skipped early. There couldn&#39;t be any changes to any computed value anyway in that case.</p>\n</blockquote>\n<ol>\n<li>If the computed signal is listening to notifications, and hasn&#39;t been notified since the last run, then bail out &amp; return the cached value.</li>\n</ol>\n<blockquote>\n<p>When a computed signal gets a notification from its dependencies, it flags the cached value as outdated. As described earlier, computed signals don&#39;t always get notifications. But when they do we can take advantage of it.</p>\n</blockquote>\n<ol>\n<li>Re-evaluate the dependencies in order. Check their version numbers. If no dependency has changed its version number, even after re-evaluation, then bail out &amp; return the cached value.</li>\n</ol>\n<blockquote>\n<p>This step is the reason why we gave special love and care to keeping dependencies in their order of use. If a dependency changes, then we don&#39;t want to re-evaluate dependencies coming later in the list because it might just be unnecessary work. Who knows, maybe the change in that first dependency causes the next compute function run to drop the latter dependencies.</p>\n</blockquote>\n<ol>\n<li>Run the compute function. If the returned value is different from the cached one, then increment the computed signal&#39;s version number. Cache and return the new value.</li>\n</ol>\n<blockquote>\n<p>This is the last resort! But at least if the new value is equal to the cached one, then the version number won&#39;t change, and the dependents down the line can use that to optimize their own caching.</p>\n</blockquote>\n<p>The last two steps often recurse into the dependencies. That&#39;s why the earlier steps are designed to try to short-circuit the recursion.</p>\n<h1>Endgame</h1><p>In typical Preact fashion there were multiple smaller optimizations thrown in along the way. <a href=\"https://github.com/preactjs/signals/tree/main/packages/core/src\" target=\"_blank\" rel=\"noopener noreferrer\">The source code</a> contains some comments that may or may not be useful. Check out the <a href=\"https://github.com/preactjs/signals/tree/main/packages/core/test\" target=\"_blank\" rel=\"noopener noreferrer\">tests</a> if you&#39;re curious about what kinds of corner cases we came up with to ensure our implementation is robust.</p>\n<p>This post was a brain dump of sorts. It outlined the main steps we took to make <strong>@preact/signals-core</strong> version 1.2.0 better - to some definition of &quot;better&quot;. Hopefully some of the ideas listed here will resonate, and get reused and remixed by others. At least that&#39;s the dream!</p>\n<p>Huge thanks to everyone who contributed. And thanks to you for reading this far! It&#39;s been a trip.</p>\n"}